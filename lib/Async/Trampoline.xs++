#define PERL_NO_GET_CONTEXT

#include "ConvertErrorsXS.h"

extern "C" {
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
}

#include "Async.h"

static
void*
copy_sv_ref(void* sv)
{
    SvREFCNT_inc((SV*) sv);
    return sv;
}

static
void
destroy_sv_ref(void* sv)
{
    SvREFCNT_dec((SV*) sv);
}

static Destructible_Vtable sv_vtable { destroy_sv_ref, copy_sv_ref };

static
AsyncRef
invoke_cv(CV* callback, DestructibleTuple const& args)
{
    assert(callback);

    if (ASYNC_TRAMPOLINE_DEBUG)
    {
        SV* name_sv = cv_name(callback, NULL, 0);
        const char* name = SvPV_nolen(name_sv);
        const char* file = CvFILE(callback);
        const COP* location = (const COP*) CvSTART(callback);
        int line = (location) ? CopLINE(location) : 0;

        ASYNC_LOG_DEBUG(
                "running Perl callback %p: %s() at %s line %d\n",
                callback, name, file, line);
    }

    dSP;

    ENTER;
    SAVETMPS;

    PUSHMARK(SP);
    if (args.size)
    {
        EXTEND(SP, args.size);
        for (auto arg : args)
        {
            ASYNC_LOG_DEBUG("  - arg %p\n", arg);
            PUSHs((SV*) arg);
        }
        PUTBACK;
    }
    else
    {
        ASYNC_LOG_DEBUG("  no args\n");
    }

    int count = call_sv((SV*) callback, G_SCALAR|G_EVAL);

    SPAGAIN;

    assert(count == 1);  // safe because scalar context

    AsyncRef result{};

    SV* error = ERRSV;
    if (SvTRUE(error))
    {
        POPs;  // discard scalar return value
        result = Async::alloc();
        Destructible error_temp { newSVsv(error), &sv_vtable };
        result->set_to_Error(std::move(error_temp));
    }
    else
    {
        SV* result_sv = POPs;

        if (!sv_isa(result_sv, "Async::Trampoline"))
            croak("Async callback must return another Async!");

        result = (Async*) SvIV(SvRV(result_sv));
    }

    FREETMPS;
    LEAVE;

    return result;
}

class InvokeCV
{
    Destructible context;
public:
    explicit InvokeCV(Destructible context) : context{std::move(context)} {}

    InvokeCV(CV* callback) : InvokeCV{{callback, &sv_vtable}}
    { SvREFCNT_inc(callback); }

    auto operator() (DestructibleTuple const& args) -> AsyncRef
    {
        CV* callback = (CV*) context.data;
        return invoke_cv(callback, args);
    }
};

MODULE = Async::Trampoline PACKAGE = Async::Trampoline

void
Async::run_until_completion()
    INIT:
        CXX_TRY
        Async* async = THIS;
    PPCODE:
    {
        Async_run_until_completion(async);

        async = &async->ptr_follow();

        if (async->type < Async_Type::CATEGORY_COMPLETE)
            croak(  "run_until_completion() did not complete the Async "
                    "(type code %d)",
                    async->type);

        if (async->type == Async_Type::IS_CANCEL)
        {
            croak("run_until_completion(): Async was cancelled");
        }
        else if (async->type == Async_Type::IS_ERROR)
        {
            croak_sv((SV*) async->as_error.data);
        }
        else if (async->type == Async_Type::IS_VALUE)
        {
            DestructibleTuple& values = async->as_value;
            for (auto value : values)
                XPUSHs(sv_2mortal(newSVsv((SV*) value)));
        }
        else
        {
            assert(0);
        }
    }
    CXX_CATCH

void
Async::DESTROY()
    INIT:
        CXX_TRY
    CODE:
        THIS->unref();
    CLEANUP:
        CXX_CATCH

Async*
async(body)
        CV* body
    PROTOTYPE: &
    INIT:
        CXX_TRY
    CODE:
    {
        AsyncRef self = Async::alloc();
        self->set_to_Thunk(InvokeCV{body}, nullptr);
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
await(dep, body)
        Async*  dep;
        CV*     body;
    PROTOTYPE: $&
    INIT:
        CXX_TRY
    CODE:
    {
        AsyncRef self = Async::alloc();
        self->set_to_Thunk(InvokeCV{body}, dep);
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
async_value(...)
    PROTOTYPE: @
    INIT:
        CXX_TRY
    CODE:
    {
        DestructibleTuple values{&sv_vtable, (size_t) items};
        for (size_t i = 0; i < items; i++)
            values.set(i, Destructible { newSVsv(ST(i)), &sv_vtable });

        AsyncRef self = Async::alloc();
        self->set_to_Value(std::move(values));
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
async_error(message)
        SV* message
    PROTOTYPE: $;
    INIT:
        CXX_TRY
    CODE:
    {
        Destructible value{ newSVsv(message), &sv_vtable };
        AsyncRef self = Async::alloc();
        self->set_to_Error(std::move(value));
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
async_cancel()
    PROTOTYPE:
    INIT:
        CXX_TRY
    CODE:
    {
        AsyncRef self = Async::alloc();
        self->set_to_Cancel();
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
Async::resolved_or(orelse)
        Async*  orelse;
    PROTOTYPE: DISABLE
    INIT:
        CXX_TRY
    CODE:
    {
        AsyncRef self = Async::alloc();
        self->set_to_ResolvedOr(THIS, orelse);
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

SV*
Async::to_string()
    PROTOTYPE: DISABLE
    INIT:
        CXX_TRY
    CODE:
    {
        RETVAL = newSVpvf("<Async 0x%zx %s>",
                (size_t) THIS,
                Async_Type_name(THIS->type));
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

#define ASYNC_TYPE_GET(name) (static_cast<I32>(Async_Type::name))
#define ASYNC_TYPE_CATEGORY_COMPLETE ASYNC_TYPE_GET(CATEGORY_COMPLETE)
#define ASYNC_TYPE_CATEGORY_RESOLVED ASYNC_TYPE_GET(CATEGORY_RESOLVED)
#define ASYNC_TYPE_IS_CANCEL ASYNC_TYPE_GET(IS_CANCEL)
#define ASYNC_TYPE_IS_ERROR ASYNC_TYPE_GET(IS_ERROR)
#define ASYNC_TYPE_IS_VALUE ASYNC_TYPE_GET(IS_VALUE)

bool
Async::is_complete()
    ALIAS:
        is_complete = ASYNC_TYPE_CATEGORY_COMPLETE
        is_resolved = ASYNC_TYPE_CATEGORY_RESOLVED
    INIT:
        CXX_TRY
    CODE:
        RETVAL = THIS->has_category(static_cast<Async_Type>(ix));
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

bool
Async::is_cancelled()
    ALIAS:
        is_cancelled = ASYNC_TYPE_IS_CANCEL
        is_error     = ASYNC_TYPE_IS_ERROR
        is_value     = ASYNC_TYPE_IS_VALUE
    INIT:
        CXX_TRY
    CODE:
        RETVAL = THIS->has_type(static_cast<Async_Type>(ix));
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH
