#define PERL_NO_GET_CONTEXT

#include "ConvertErrorsXS.h"

extern "C" {
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
}

#include "Async.h"

static void* copy_sv_ref(void* sv);
static void destroy_sv_ref(void* sv);
static size_t get_refcount_sv(void* sv);
static const char* get_stringification_sv(void* sv);

static Destructible_Vtable sv_vtable {
        destroy_sv_ref,
        copy_sv_ref,
        get_refcount_sv,
        get_stringification_sv,
};

static void* copy_sv_ref(void* sv)
{
    ASYNC_LOG_DEBUG("copy_sv_ref: " DESTRUCTIBLE_FORMAT "\n",
            DESTRUCTIBLE_FORMAT_ARGS_BORROWED(&sv_vtable, sv));
    SvREFCNT_inc((SV*) sv);
    return sv;
}

static void destroy_sv_ref(void* sv)
{
    ASYNC_LOG_DEBUG("destroy_sv_ref: " DESTRUCTIBLE_FORMAT "\n",
            DESTRUCTIBLE_FORMAT_ARGS_BORROWED(&sv_vtable, sv));
    SvREFCNT_dec((SV*) sv);
}

static size_t get_refcount_sv(void* sv)
{
    return SvREFCNT((SV*) sv);
}

static const char* get_stringification_sv(void* sv)
{
    return (SvOK((SV*) sv)) ? SvPV_nolen((SV*) sv) : "<undef>";
}

static
AsyncRef
invoke_cv(CV* callback, DestructibleTuple const& args)
{
    assert(callback);

    if (ASYNC_TRAMPOLINE_DEBUG)
    {
        SV* name_sv = cv_name(callback, NULL, 0);
        const char* name = SvPV_nolen(name_sv);
        const char* file = CvFILE(callback);
        const COP* location = (const COP*) CvSTART(callback);
        int line = (location) ? CopLINE(location) : 0;

        ASYNC_LOG_DEBUG(
                "running Perl callback %p: %s() at %s line %d\n",
                callback, name, file, line);
    }

    dSP;

    ENTER;
    SAVETMPS;

    PUSHMARK(SP);
    if (args.size)
    {
        EXTEND(SP, args.size);
        for (auto arg : args)
        {
            ASYNC_LOG_DEBUG("  - arg %p refs=%zu content=%s\n",
                    arg,
                    (size_t) SvREFCNT((SV*) arg),
                    SvPV_nolen((SV*) arg));

            PUSHs((SV*) arg);
        }
        PUTBACK;
    }
    else
    {
        ASYNC_LOG_DEBUG("  no args\n");
    }

    int count = call_sv((SV*) callback, G_SCALAR|G_EVAL);

    SPAGAIN;

    assert(count == 1);  // safe because scalar context

    AsyncRef result{};

    SV* error = ERRSV;
    if (SvTRUE(error))
    {
        POPs;  // discard scalar return value
        result = Async::alloc();
        Destructible error_temp { newSVsv(error), &sv_vtable };
        result->set_to_Error(std::move(error_temp));
    }
    else
    {
        SV* result_sv = POPs;

        if (!sv_isa(result_sv, "Async::Trampoline"))
            croak("Async callback must return another Async!");

        result = (Async*) SvIV(SvRV(result_sv));
    }

    FREETMPS;
    LEAVE;

    return result;
}

class InvokeCV
{
    Destructible context;
public:
    explicit InvokeCV(Destructible context) : context{std::move(context)} {}

    InvokeCV(CV* callback) : InvokeCV{{callback, &sv_vtable}}
    { SvREFCNT_inc(callback); }

    auto operator() (DestructibleTuple const& args) -> AsyncRef
    {
        CV* callback = (CV*) context.data;
        return invoke_cv(callback, args);
    }
};

static AsyncRef make_async_yield(AsyncRef&& continuation, AsyncRef&& value)
{
    // wrap continuation as SV
    DestructibleTuple continuation_tuple { &sv_vtable, 1 };
    SV* continuation_sv = nullptr;
    continuation_tuple.set(0, { continuation_sv = newSV(0), &sv_vtable });
    sv_setref_pv(
            continuation_sv,
            "Async::Trampoline",
            continuation.ptr_with_ownership());

    AsyncRef continuation_tuple_async = Async::alloc();
    continuation_tuple_async->set_to_Value(std::move(continuation_tuple));

    AsyncRef yield = Async::alloc();
    yield->set_to_Concat(continuation_tuple_async, value);

    return yield;
}

#define ASYNC_TYPE_GET(name) (static_cast<I32>(Async_Type::name))
#define ASYNC_TYPE_CATEGORY_COMPLETE    ASYNC_TYPE_GET(CATEGORY_COMPLETE)
#define ASYNC_TYPE_CATEGORY_RESOLVED    ASYNC_TYPE_GET(CATEGORY_RESOLVED)
#define ASYNC_TYPE_IS_CANCEL            ASYNC_TYPE_GET(IS_CANCEL)
#define ASYNC_TYPE_IS_ERROR             ASYNC_TYPE_GET(IS_ERROR)
#define ASYNC_TYPE_IS_VALUE             ASYNC_TYPE_GET(IS_VALUE)

MODULE = Async::Trampoline PACKAGE = Async::Trampoline

void
Async::run_until_completion()
    INIT:
        CXX_TRY
    PPCODE:
    {
        Async_run_until_completion(THIS);

        Async& result = THIS->ptr_follow();

        if (!result.has_category(Async_Type::CATEGORY_COMPLETE))
        {
            croak(  "run_until_completion() did not complete " ASYNC_FORMAT,
                    ASYNC_FORMAT_ARGS(result));
        }
        else if (result.has_type(Async_Type::IS_CANCEL))
        {
            croak("run_until_completion(): Async was cancelled");
        }
        else if (result.has_type(Async_Type::IS_ERROR))
        {
            croak_sv((SV*) result.as_error.data);
        }
        else if (result.has_type(Async_Type::IS_VALUE))
        {
            ASYNC_LOG_DEBUG("returning to Perl: " ASYNC_FORMAT "\n",
                    ASYNC_FORMAT_ARGS(result));

            DestructibleTuple& values = result.as_value;
            XSprePUSH;  // to fix weird XS+PPCODE argument handling
            EXTEND(SP, values.size);
            for (auto value : values)
            {
                ASYNC_LOG_DEBUG("  - " DESTRUCTIBLE_FORMAT "\n",
                        DESTRUCTIBLE_FORMAT_ARGS_BORROWED(values.vtable, value));
                PUSHs(sv_mortalcopy((SV*) value));
            }

            ASYNC_LOG_DEBUG("result end\n");

            XSRETURN(values.size);
        }
        else
        {
            assert(0);
        }
    }
    CXX_CATCH

void
Async::DESTROY()
    INIT:
        CXX_TRY
    CODE:
        THIS->unref();
    CLEANUP:
        CXX_CATCH

Async*
async(body)
        CV* body
    PROTOTYPE: &
    INIT:
        CXX_TRY
    CODE:
    {
        AsyncRef self = Async::alloc();
        self->set_to_Thunk(InvokeCV{body}, nullptr);
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
await(dep, body)
        Async*  dep;
        CV*     body;
    PROTOTYPE: $&
    INIT:
        CXX_TRY
    CODE:
    {
        AsyncRef self = Async::alloc();
        self->set_to_Thunk(InvokeCV{body}, dep);
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
async_value(...)
    PROTOTYPE: @
    INIT:
        CXX_TRY
    CODE:
    {
        DestructibleTuple values{&sv_vtable, (size_t) items};
        for (size_t i = 0; i < items; i++)
            values.set(i, Destructible { newSVsv(ST(i)), &sv_vtable });

        AsyncRef self = Async::alloc();
        self->set_to_Value(std::move(values));
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
async_error(message)
        SV* message
    PROTOTYPE: $;
    INIT:
        CXX_TRY
    CODE:
    {
        Destructible value{ newSVsv(message), &sv_vtable };
        AsyncRef self = Async::alloc();
        self->set_to_Error(std::move(value));
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
async_cancel()
    PROTOTYPE:
    INIT:
        CXX_TRY
    CODE:
    {
        AsyncRef self = Async::alloc();
        self->set_to_Cancel();
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
async_yield(async, callback)
        Async*  async
        CV*     callback
    PROTOTYPE: $&
    INIT:
        CXX_TRY
    CODE:
    {
        AsyncRef continuation = Async::alloc();
        continuation->set_to_Thunk(InvokeCV{callback}, nullptr);

        AsyncRef yield = make_async_yield(std::move(continuation), async);
        RETVAL = yield.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
Async::resolved_or(orelse)
        Async*  orelse;
    ALIAS:
        resolved_or = ASYNC_TYPE_CATEGORY_RESOLVED
        value_or    = ASYNC_TYPE_IS_VALUE
    INIT:
        CXX_TRY
    CODE:
    {
        AsyncRef self = Async::alloc();
        self->set_to_Flow({
                THIS, orelse,
                static_cast<Async_Type>(ix),
                Async_Flow::OR,
        });
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
Async::resolved_then(then)
        Async*  then;
    ALIAS:
        complete_then   = ASYNC_TYPE_CATEGORY_COMPLETE
        resolved_then   = ASYNC_TYPE_CATEGORY_RESOLVED
        value_then      = ASYNC_TYPE_IS_VALUE
    INIT:
        CXX_TRY
    CODE:
    {
        AsyncRef self = Async::alloc();
        self->set_to_Flow({
                THIS, then,
                static_cast<Async_Type>(ix),
                Async_Flow::THEN,
        });
        RETVAL = self.ptr_with_ownership();
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

SV*
Async::to_string()
    PROTOTYPE: DISABLE
    INIT:
        CXX_TRY
    CODE:
    {
        RETVAL = newSVpvf(ASYNC_FORMAT,
                ASYNC_FORMAT_ARGS(*THIS));
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

bool
Async::is_complete()
    ALIAS:
        is_complete = ASYNC_TYPE_CATEGORY_COMPLETE
        is_resolved = ASYNC_TYPE_CATEGORY_RESOLVED
    INIT:
        CXX_TRY
    CODE:
        RETVAL = THIS->has_category(static_cast<Async_Type>(ix));
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

bool
Async::is_cancelled()
    ALIAS:
        is_cancelled = ASYNC_TYPE_IS_CANCEL
        is_error     = ASYNC_TYPE_IS_ERROR
        is_value     = ASYNC_TYPE_IS_VALUE
    INIT:
        CXX_TRY
    CODE:
        RETVAL = THIS->has_type(static_cast<Async_Type>(ix));
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH
