#define PERL_NO_GET_CONTEXT

#include "ConvertErrorsXS.h"

extern "C" {
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
}

#include "Async.h"

static
void*
copy_sv_ref(void* sv)
{
    SvREFCNT_inc((SV*) sv);
    return sv;
}

static
void
destroy_sv_ref(void* sv)
{
    SvREFCNT_dec((SV*) sv);
}

static Destructible_Vtable sv_vtable { destroy_sv_ref, copy_sv_ref };

static
AsyncRef
invoke_cv(Destructible body_container, DestructibleTuple const& args)
{
    CV* callback = (CV*) body_container.data;
    assert(callback);

    if (ASYNC_TRAMPOLINE_DEBUG)
    {
        SV* name_sv = cv_name(callback, NULL, 0);
        const char* name = SvPV_nolen(name_sv);
        const char* file = CvFILE(callback);
        const COP* location = (const COP*) CvSTART(callback);
        int line = (location) ? CopLINE(location) : 0;

        ASYNC_LOG_DEBUG(
                "running Perl callback %p: %s() at %s line %d\n",
                callback, name, file, line);
    }

    dSP;

    ENTER;
    SAVETMPS;

    PUSHMARK(SP);
    if (args.size)
    {
        EXTEND(SP, args.size);
        for (auto arg : args)
        {
            ASYNC_LOG_DEBUG("  - arg %p\n", arg);
            PUSHs((SV*) arg);
        }
        PUTBACK;
    }
    else
    {
        ASYNC_LOG_DEBUG("  no args\n");
    }

    // TODO handle exceptions
    int count = call_sv((SV*) callback, G_SCALAR);

    SPAGAIN;

    assert(count == 1);  // safe because scalar context

    SV* result_sv = POPs;

    if (!sv_isa(result_sv, "Async::Trampoline"))
        croak("Async callback must return another Async!");

    AsyncRef result = (Async*) SvIV(SvRV(result_sv));

    FREETMPS;
    LEAVE;

    return result;
}

MODULE = Async::Trampoline PACKAGE = Async::Trampoline

void
run_until_completion(async)
        Async* async;
    PROTOTYPE: $;
    INIT:
        CXX_TRY
    PPCODE:
    {
        Async_run_until_completion(async);

        async = Async_Ptr_follow(async);

        if (async->type < Async_Type::CATEGORY_COMPLETE)
            croak(  "run_until_completion() did not complete the Async "
                    "(type code %d)",
                    async->type);

        if (async->type == Async_Type::IS_CANCEL)
        {
            croak("run_until_completion(): Async was cancelled");
        }
        else if (async->type == Async_Type::IS_ERROR)
        {
            croak_sv((SV*) async->as_error.data);
        }
        else if (async->type == Async_Type::IS_VALUE)
        {
            DestructibleTuple& values = async->as_value;
            for (auto value : values)
                XPUSHs(sv_2mortal(newSVsv((SV*) value)));
        }
        else
        {
            assert(0);
        }
    }
    CXX_CATCH

void
DESTROY(async)
        Async* async;
    INIT:
        CXX_TRY
    CODE:
        async->unref();
    CLEANUP:
        CXX_CATCH

Async*
async(body)
        CV* body
    PROTOTYPE: &
    INIT:
        CXX_TRY
    CODE:
    {
        Async* self = &Async::alloc()->ref();
        Async_Thunk_init(
                self,
                invoke_cv,
                Destructible{body, &sv_vtable},
                NULL);
        SvREFCNT_inc(body);
        RETVAL = self;
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
await(dep, body)
        Async*  dep;
        CV*     body;
    PROTOTYPE: $&
    INIT:
        CXX_TRY
    CODE:
    {
        Async* self = &Async::alloc()->ref();
        Async_Thunk_init(
                self,
                invoke_cv,
                Destructible{body, &sv_vtable},
                dep);
        SvREFCNT_inc(body);
        RETVAL = self;
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
async_value(...)
    PROTOTYPE: @
    INIT:
        CXX_TRY
    CODE:
    {
        DestructibleTuple values{&sv_vtable, (size_t) items};
        for (size_t i = 0; i < items; i++)
        {
            Destructible destructible_value{
                newSVsv(ST(i)),
                &sv_vtable,
            };
            values.set(i, std::move(destructible_value));
        }

        Async* self = &Async::alloc()->ref();
        Async_Value_init(self, std::move(values));
        RETVAL = self;
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
async_cancel()
    PROTOTYPE:
    INIT:
        CXX_TRY
    CODE:
    {
        Async* self = &Async::alloc()->ref();
        Async_Cancel_init(self);
        RETVAL = self;
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

Async*
async_resolved_or(first, orelse)
        Async*  first;
        Async*  orelse;
    PROTOTYPE: DISABLE
    INIT:
        CXX_TRY
    CODE:
    {
        Async* self = &Async::alloc()->ref();
        Async_ResolvedOr_init(self, first, orelse);
        RETVAL = self;
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH

SV*
to_string(self)
        Async*  self;
    PROTOTYPE: DISABLE
    INIT:
        CXX_TRY
    CODE:
    {
        RETVAL = newSVpvf("<Async 0x%zx %s>", (size_t) self, Async_Type_name(self->type));
    }
    OUTPUT: RETVAL
    CLEANUP:
        CXX_CATCH
